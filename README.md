| l.p | Data structure name         | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Lang | Paradigm                                                                                                                                       |
|-----|-----------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------|------------------------------------------------------------------------------------------------------------------------------------------------|
| 1   | Dynamic array               | 1. Implementation of an array of pointers to objects.<br>(Employee** arrOfEmployees = new Employee* [numberOfEmployees];).<br><br>2. Array is being bubble-sorted (optimized version)<br><br>3. FisherYates shuffling is used for Employee->uniqueValue generation.                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | C++  | structural                                                                                                                                     |
| 2   | SkipList                    | Implementation of a SkipList.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | C++  | object oriented but classes are in single cpp file                                                                                             |
| 3   | Binary Search Tree with DSW | Binary Search Tree with possibility to make a right or left backbone and balancing the backbone algorithm (Day-Stout-Warren algorithm)..                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | C++  | object oriented but classes are in single cpp file                                                                                             |
| 4   | HashTable & List            | Generic HashTable<TKey, TNode, THashFunc> partial implementation with tree strategies resolving collisions (scenario where same index value is generated by hashfunction):<br>a) Chaining, where it assumes that on collision  a LinkedList is being created for all collisions nodes.<br><br>b) Linear probing, where it assumes that on collision we try to find a place as close as possible to the given node<br><br>c) DoubleHashing, where it assumes that if first hash function resulted in collision, the second is used<br><br>I also accidentally implemented simple  List (LinkedList) because I thought it would be useful for linear probing strategy, but I've just expanded TblNode with *TblNode _next field and was not needed :) | C++  | object oriented with classes organized in several(.h and .cpp) files instead of<br>having all in single main.cpp. c++ templates were also used |
| 5   | BinaryHeap                  | Minimum oriented binary heap implementation with a very inefficient solution using LinkedList under the hood.<br><br>Insertion of 10^6 elements takes around 3~ minutes and nodes removal about 1 minute~. <br><br>This is because when we insert a node at the end and perculate-up takes place, swapping elements on a LinkedList takes a lot of time.<br>Finding two elements to be swapped with indexes: 'i', 'j' cause 'i' + 'j' nodes visiting and so the perculation-up <br>for the element that is added at the end of the LinkedList will cause a lot of unnecessary nodes visiting. <br><br>This could be accelerated by using regular array of Nodes, but this was just for experimental purposes.                                    | C++  | object oriented with classes organized in sever(.h and .cpp) files. c++ templates were also used.                                              |
| 6   | List                  | List which holds Car structure and it does resize on every insertion. Resizing is handled in a inefficient way as size is increased by 1 only on every insertion. It means that for every new Car inserted into the list, the whole list is copied into a new one, which is only 1 size larger.                                     | C++  | structural                                             |
